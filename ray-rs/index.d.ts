/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Single-file graph database */
export declare class Database {
  /** Open a database file */
  static open(path: string, options?: OpenOptions | undefined | null): Database
  /** Close the database */
  close(): void
  /** Check if database is open */
  get isOpen(): boolean
  /** Get database path */
  get path(): string
  /** Check if database is read-only */
  get readOnly(): boolean
  /** Begin a transaction */
  begin(readOnly?: boolean | undefined | null): number
  /** Commit the current transaction */
  commit(): void
  /** Rollback the current transaction */
  rollback(): void
  /** Check if there's an active transaction */
  hasTransaction(): boolean
  /** Create a new node */
  createNode(key?: string | undefined | null): number
  /** Delete a node */
  deleteNode(nodeId: number): void
  /** Check if a node exists */
  nodeExists(nodeId: number): boolean
  /** Get node by key */
  getNodeByKey(key: string): number | null
  /** Get the key for a node */
  getNodeKey(nodeId: number): string | null
  /** List all node IDs */
  listNodes(): Array<number>
  /** Count all nodes */
  countNodes(): number
  /** Add an edge */
  addEdge(src: number, etype: number, dst: number): void
  /** Add an edge by type name */
  addEdgeByName(src: number, etypeName: string, dst: number): void
  /** Delete an edge */
  deleteEdge(src: number, etype: number, dst: number): void
  /** Check if an edge exists */
  edgeExists(src: number, etype: number, dst: number): boolean
  /** Get outgoing edges for a node */
  getOutEdges(nodeId: number): Array<JsEdge>
  /** Get incoming edges for a node */
  getInEdges(nodeId: number): Array<JsEdge>
  /** Get out-degree for a node */
  getOutDegree(nodeId: number): number
  /** Get in-degree for a node */
  getInDegree(nodeId: number): number
  /** Count all edges */
  countEdges(): number
  /**
   * List all edges in the database
   *
   * Returns an array of {src, etype, dst} objects representing all edges.
   * Optionally filter by edge type.
   */
  listEdges(etype?: number | undefined | null): Array<JsFullEdge>
  /**
   * List edges by type name
   *
   * Returns an array of {src, etype, dst} objects for the given edge type.
   */
  listEdgesByName(etypeName: string): Array<JsFullEdge>
  /** Count edges by type */
  countEdgesByType(etype: number): number
  /** Count edges by type name */
  countEdgesByName(etypeName: string): number
  /** Set a node property */
  setNodeProp(nodeId: number, keyId: number, value: JsPropValue): void
  /** Set a node property by key name */
  setNodePropByName(nodeId: number, keyName: string, value: JsPropValue): void
  /** Delete a node property */
  deleteNodeProp(nodeId: number, keyId: number): void
  /** Get a specific node property */
  getNodeProp(nodeId: number, keyId: number): JsPropValue | null
  /** Get all properties for a node (returns array of {key_id, value} pairs) */
  getNodeProps(nodeId: number): Array<JsNodeProp> | null
  /** Set an edge property */
  setEdgeProp(src: number, etype: number, dst: number, keyId: number, value: JsPropValue): void
  /** Set an edge property by key name */
  setEdgePropByName(src: number, etype: number, dst: number, keyName: string, value: JsPropValue): void
  /** Delete an edge property */
  deleteEdgeProp(src: number, etype: number, dst: number, keyId: number): void
  /** Get a specific edge property */
  getEdgeProp(src: number, etype: number, dst: number, keyId: number): JsPropValue | null
  /** Get all properties for an edge (returns array of {key_id, value} pairs) */
  getEdgeProps(src: number, etype: number, dst: number): Array<JsNodeProp> | null
  /** Set a vector embedding for a node */
  setNodeVector(nodeId: number, propKeyId: number, vector: Array<number>): void
  /** Get a vector embedding for a node */
  getNodeVector(nodeId: number, propKeyId: number): Array<number> | null
  /** Delete a vector embedding for a node */
  deleteNodeVector(nodeId: number, propKeyId: number): void
  /** Check if a node has a vector embedding */
  hasNodeVector(nodeId: number, propKeyId: number): boolean
  /** Get or create a label ID */
  getOrCreateLabel(name: string): number
  /** Get label ID by name */
  getLabelId(name: string): number | null
  /** Get label name by ID */
  getLabelName(id: number): string | null
  /** Get or create an edge type ID */
  getOrCreateEtype(name: string): number
  /** Get edge type ID by name */
  getEtypeId(name: string): number | null
  /** Get edge type name by ID */
  getEtypeName(id: number): string | null
  /** Get or create a property key ID */
  getOrCreatePropkey(name: string): number
  /** Get property key ID by name */
  getPropkeyId(name: string): number | null
  /** Get property key name by ID */
  getPropkeyName(id: number): string | null
  /** Define a new label (requires transaction) */
  defineLabel(name: string): number
  /** Add a label to a node */
  addNodeLabel(nodeId: number, labelId: number): void
  /** Add a label to a node by name */
  addNodeLabelByName(nodeId: number, labelName: string): void
  /** Remove a label from a node */
  removeNodeLabel(nodeId: number, labelId: number): void
  /** Check if a node has a label */
  nodeHasLabel(nodeId: number, labelId: number): boolean
  /** Get all labels for a node */
  getNodeLabels(nodeId: number): Array<number>
  /** Perform a checkpoint (compact WAL into snapshot) */
  checkpoint(): void
  /** Perform a background (non-blocking) checkpoint */
  backgroundCheckpoint(): void
  /** Check if checkpoint is recommended */
  shouldCheckpoint(threshold?: number | undefined | null): boolean
  /**
   * Optimize (compact) the database
   *
   * This is an alias for `checkpoint()` to match the TypeScript API.
   * For single-file databases, optimization means merging the WAL into
   * the snapshot, which reduces file size and improves read performance.
   */
  optimize(): void
  /** Get database statistics */
  stats(): DbStats
  /** Check if caching is enabled */
  cacheIsEnabled(): boolean
  /** Invalidate all caches for a node */
  cacheInvalidateNode(nodeId: number): void
  /** Invalidate caches for a specific edge */
  cacheInvalidateEdge(src: number, etype: number, dst: number): void
  /** Invalidate a cached key lookup */
  cacheInvalidateKey(key: string): void
  /** Clear all caches */
  cacheClear(): void
  /** Clear only the query cache */
  cacheClearQuery(): void
  /** Clear only the key cache */
  cacheClearKey(): void
  /** Clear only the property cache */
  cacheClearProperty(): void
  /** Clear only the traversal cache */
  cacheClearTraversal(): void
  /** Get cache statistics */
  cacheStats(): JsCacheStats | null
  /** Reset cache statistics */
  cacheResetStats(): void
}

/**
 * Stored graph data for traversal operations
 *
 * Since NAPI doesn't support passing closures directly, we need to
 * store the graph data and query it. This struct holds edge lists
 * indexed by source and destination.
 */
export declare class JsGraphAccessor {
  /** Create a new empty graph accessor */
  constructor()
  /**
   * Add an edge to the graph
   *
   * @param src - Source node ID
   * @param etype - Edge type ID
   * @param dst - Destination node ID
   * @param weight - Optional edge weight (default: 1.0)
   */
  addEdge(src: number, etype: number, dst: number, weight?: number | undefined | null): void
  /**
   * Add multiple edges at once (more efficient than individual adds)
   *
   * @param edges - Array of [src, etype, dst, weight?] tuples
   */
  addEdges(edges: Array<JsEdgeInput>): void
  /** Clear all edges */
  clear(): void
  /** Get the number of edges */
  edgeCount(): number
  /** Get the number of unique nodes */
  nodeCount(): number
  /**
   * Execute a single-hop traversal from start nodes
   *
   * @param startNodes - Array of starting node IDs
   * @param direction - Traversal direction
   * @param edgeType - Optional edge type filter
   * @returns Array of traversal results
   */
  traverseSingle(startNodes: Array<number>, direction: JsTraversalDirection, edgeType?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a multi-hop traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps (direction, edgeType)
   * @param limit - Maximum number of results
   * @returns Array of traversal results
   */
  traverse(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a variable-depth traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param edgeType - Optional edge type filter
   * @param options - Traversal options (maxDepth, minDepth, direction, unique)
   * @returns Array of traversal results
   */
  traverseDepth(startNodes: Array<number>, edgeType: number | undefined | null, options: JsTraverseOptions): Array<JsTraversalResult>
  /**
   * Count traversal results without materializing them
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @returns Number of results
   */
  traverseCount(startNodes: Array<number>, steps: Array<JsTraversalStep>): number
  /**
   * Get just the node IDs from a traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @param limit - Maximum number of results
   * @returns Array of node IDs
   */
  traverseNodeIds(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<number>
  /**
   * Find shortest path using Dijkstra's algorithm
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  dijkstra(config: JsPathConfig): JsPathResult
  /**
   * Find shortest path using BFS (unweighted)
   *
   * Faster than Dijkstra for unweighted graphs.
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  bfs(config: JsPathConfig): JsPathResult
  /**
   * Find k shortest paths using Yen's algorithm
   *
   * @param config - Pathfinding configuration
   * @param k - Maximum number of paths to find
   * @returns Array of path results sorted by weight
   */
  kShortest(config: JsPathConfig, k: number): Array<JsPathResult>
  /**
   * Find shortest path between two nodes (convenience method)
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns Path result
   */
  shortestPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): JsPathResult
  /**
   * Check if a path exists between two nodes
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns true if path exists
   */
  hasPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): boolean
  /**
   * Get all nodes reachable from a source within a certain depth
   *
   * @param source - Source node ID
   * @param maxDepth - Maximum depth to traverse
   * @param edgeType - Optional edge type filter
   * @returns Array of reachable node IDs
   */
  reachableNodes(source: number, maxDepth: number, edgeType?: number | undefined | null): Array<number>
}

/** IVF (Inverted File) index for approximate nearest neighbor search */
export declare class JsIvfIndex {
  /** Create a new IVF index */
  constructor(dimensions: number, config?: JsIvfConfig | undefined | null)
  /** Get the number of dimensions */
  get dimensions(): number
  /** Check if the index is trained */
  get trained(): boolean
  /**
   * Add training vectors
   *
   * Call this before train() with representative vectors from your dataset.
   */
  addTrainingVectors(vectors: Array<number>, numVectors: number): void
  /**
   * Train the index on added training vectors
   *
   * This runs k-means clustering to create the inverted file structure.
   */
  train(): void
  /**
   * Insert a vector into the index
   *
   * The index must be trained first.
   */
  insert(vectorId: number, vector: Array<number>): void
  /**
   * Delete a vector from the index
   *
   * Requires the vector data to determine which cluster to remove from.
   */
  delete(vectorId: number, vector: Array<number>): boolean
  /** Clear all data from the index */
  clear(): void
  /**
   * Search for k nearest neighbors
   *
   * Requires a VectorManifest to look up actual vector data.
   */
  search(manifestJson: string, query: Array<number>, k: number, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /**
   * Search with multiple query vectors
   *
   * Aggregates results using the specified method.
   */
  searchMulti(manifestJson: string, queries: Array<Array<number>>, k: number, aggregation: JsAggregation, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Get index statistics */
  stats(): JsIvfStats
  /** Serialize the index to bytes */
  serialize(): Buffer
  /** Deserialize an index from bytes */
  static deserialize(data: Buffer): JsIvfIndex
}

/** IVF-PQ combined index for memory-efficient approximate nearest neighbor search */
export declare class JsIvfPqIndex {
  /** Create a new IVF-PQ index */
  constructor(dimensions: number, ivfConfig?: JsIvfConfig | undefined | null, pqConfig?: JsPqConfig | undefined | null, useResiduals?: boolean | undefined | null)
  /** Get the number of dimensions */
  get dimensions(): number
  /** Check if the index is trained */
  get trained(): boolean
  /** Add training vectors */
  addTrainingVectors(vectors: Array<number>, numVectors: number): void
  /** Train the index */
  train(): void
  /** Insert a vector */
  insert(vectorId: number, vector: Array<number>): void
  /**
   * Delete a vector
   *
   * Requires the vector data to determine which cluster to remove from.
   */
  delete(vectorId: number, vector: Array<number>): boolean
  /** Clear the index */
  clear(): void
  /** Search for k nearest neighbors using PQ distance approximation */
  search(manifestJson: string, query: Array<number>, k: number, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Search with multiple query vectors */
  searchMulti(manifestJson: string, queries: Array<Array<number>>, k: number, aggregation: JsAggregation, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Get index statistics */
  stats(): JsIvfStats
  /** Serialize the index to bytes */
  serialize(): Buffer
  /** Deserialize an index from bytes */
  static deserialize(data: Buffer): JsIvfPqIndex
}

/**
 * Perform brute-force search over all vectors
 *
 * Useful for small datasets or verifying IVF results.
 */
export declare function bruteForceSearch(vectors: Array<Array<number>>, nodeIds: Array<number>, query: Array<number>, k: number, metric?: JsDistanceMetric | undefined | null): Array<JsBruteForceResult>

/** Database statistics */
export interface DbStats {
  snapshotGen: number
  snapshotNodes: number
  snapshotEdges: number
  snapshotMaxNodeId: number
  deltaNodesCreated: number
  deltaNodesDeleted: number
  deltaEdgesAdded: number
  deltaEdgesDeleted: number
  walBytes: number
  recommendCompact: boolean
}

/** Aggregation method for multi-query search */
export declare const enum JsAggregation {
  /** Minimum distance (best match) */
  Min = 'Min',
  /** Maximum distance (worst match) */
  Max = 'Max',
  /** Average distance */
  Avg = 'Avg',
  /** Sum of distances */
  Sum = 'Sum'
}

/** Brute force search result */
export interface JsBruteForceResult {
  nodeId: number
  distance: number
  similarity: number
}

/** Cache statistics */
export interface JsCacheStats {
  propertyCacheHits: number
  propertyCacheMisses: number
  propertyCacheSize: number
  traversalCacheHits: number
  traversalCacheMisses: number
  traversalCacheSize: number
  queryCacheHits: number
  queryCacheMisses: number
  queryCacheSize: number
}

/** Distance metric for vector similarity */
export declare const enum JsDistanceMetric {
  /** Cosine similarity (1 - cosine) */
  Cosine = 'Cosine',
  /** Euclidean (L2) distance */
  Euclidean = 'Euclidean',
  /** Dot product (negated for distance) */
  DotProduct = 'DotProduct'
}

/** Edge representation for JS (neighbor style) */
export interface JsEdge {
  etype: number
  nodeId: number
}

/** Edge input for bulk loading */
export interface JsEdgeInput {
  src: number
  etype: number
  dst: number
  weight?: number
}

/** Full edge representation for JS (src, etype, dst) */
export interface JsFullEdge {
  src: number
  etype: number
  dst: number
}

/** Configuration for IVF index */
export interface JsIvfConfig {
  /** Number of clusters (default: 100) */
  nClusters?: number
  /** Number of clusters to probe during search (default: 10) */
  nProbe?: number
  /** Distance metric (default: Cosine) */
  metric?: JsDistanceMetric
}

/** Statistics for IVF index */
export interface JsIvfStats {
  /** Whether the index is trained */
  trained: boolean
  /** Number of clusters */
  nClusters: number
  /** Total vectors in the index */
  totalVectors: number
  /** Average vectors per cluster */
  avgVectorsPerCluster: number
  /** Number of empty clusters */
  emptyClusterCount: number
  /** Minimum cluster size */
  minClusterSize: number
  /** Maximum cluster size */
  maxClusterSize: number
}

/** Node property key-value pair for JS */
export interface JsNodeProp {
  keyId: number
  value: JsPropValue
}

/** Configuration for pathfinding */
export interface JsPathConfig {
  /** Source node ID */
  source: number
  /** Target node ID (for single target) */
  target?: number
  /** Multiple target node IDs (find path to any) */
  targets?: Array<number>
  /** Allowed edge types (empty = all) */
  allowedEdgeTypes?: Array<number>
  /** Traversal direction */
  direction?: JsTraversalDirection
  /** Maximum search depth */
  maxDepth?: number
}

/** An edge in a path result */
export interface JsPathEdge {
  src: number
  etype: number
  dst: number
}

/** Result of a pathfinding query */
export interface JsPathResult {
  /** Nodes in order from source to target */
  path: Array<number>
  /** Edges as [src, etype, dst] triples */
  edges: Array<JsPathEdge>
  /** Sum of edge weights along the path */
  totalWeight: number
  /** Whether a path was found */
  found: boolean
}

/** Configuration for Product Quantization */
export interface JsPqConfig {
  /** Number of subspaces (must divide dimensions evenly) */
  numSubspaces?: number
  /** Number of centroids per subspace (default: 256) */
  numCentroids?: number
  /** Max k-means iterations for training (default: 25) */
  maxIterations?: number
}

/** Property value wrapper for JS */
export interface JsPropValue {
  propType: PropType
  boolValue?: boolean
  intValue?: number
  floatValue?: number
  stringValue?: string
}

/** Options for vector search */
export interface JsSearchOptions {
  /** Number of clusters to probe (overrides index default) */
  nProbe?: number
  /** Minimum similarity threshold (0-1) */
  threshold?: number
}

/** Result of a vector search */
export interface JsSearchResult {
  /** Vector ID */
  vectorId: number
  /** Associated node ID */
  nodeId: number
  /** Distance from query */
  distance: number
  /** Similarity score (0-1, higher is more similar) */
  similarity: number
}

/**
 * Synchronization mode for WAL writes
 *
 * Controls the durability vs performance trade-off for commits.
 * - Full: Fsync on every commit (durable to OS, slowest)
 * - Normal: Fsync only on checkpoint (~1000x faster, safe from app crash)
 * - Off: No fsync (fastest, data may be lost on any crash)
 */
export declare const enum JsSyncMode {
  /** Fsync on every commit (durable to OS, slowest) */
  Full = 'Full',
  /** Fsync on checkpoint only (balanced) */
  Normal = 'Normal',
  /** No fsync (fastest, least safe) */
  Off = 'Off'
}

/** Direction for graph traversal */
export declare const enum JsTraversalDirection {
  /** Follow outgoing edges */
  Out = 'Out',
  /** Follow incoming edges */
  In = 'In',
  /** Follow edges in both directions */
  Both = 'Both'
}

/** A single result from a traversal */
export interface JsTraversalResult {
  /** The node ID that was reached */
  nodeId: number
  /** The depth (number of hops) from the start */
  depth: number
  /** Source node of the edge used (if any) */
  edgeSrc?: number
  /** Destination node of the edge used (if any) */
  edgeDst?: number
  /** Edge type used (if any) */
  edgeType?: number
}

/** A single traversal step */
export interface JsTraversalStep {
  direction: JsTraversalDirection
  edgeType?: number
}

/** Options for variable-depth traversal */
export interface JsTraverseOptions {
  /** Direction of traversal */
  direction?: JsTraversalDirection
  /** Minimum depth (default: 1) */
  minDepth?: number
  /** Maximum depth (required) */
  maxDepth: number
  /** Whether to only visit unique nodes (default: true) */
  unique?: boolean
}

/** Open a database file (standalone function) */
export declare function openDatabase(path: string, options?: OpenOptions | undefined | null): Database

/** Options for opening a database */
export interface OpenOptions {
  /** Open in read-only mode */
  readOnly?: boolean
  /** Create database if it doesn't exist */
  createIfMissing?: boolean
  /** Page size in bytes (default 4096) */
  pageSize?: number
  /** WAL size in bytes (default 1MB) */
  walSize?: number
  /** Enable auto-checkpoint when WAL usage exceeds threshold */
  autoCheckpoint?: boolean
  /** WAL usage threshold (0.0-1.0) to trigger auto-checkpoint */
  checkpointThreshold?: number
  /** Use background (non-blocking) checkpoint */
  backgroundCheckpoint?: boolean
  /** Enable caching */
  cacheEnabled?: boolean
  /** Max node properties in cache */
  cacheMaxNodeProps?: number
  /** Max edge properties in cache */
  cacheMaxEdgeProps?: number
  /** Max traversal cache entries */
  cacheMaxTraversalEntries?: number
  /** Max query cache entries */
  cacheMaxQueryEntries?: number
  /** Query cache TTL in milliseconds */
  cacheQueryTtlMs?: number
  /** Sync mode: "Full", "Normal", or "Off" (default: "Full") */
  syncMode?: JsSyncMode
}

/**
 * Create a path configuration
 *
 * @param source - Source node ID
 * @param target - Target node ID
 * @returns Path configuration object
 */
export declare function pathConfig(source: number, target: number): JsPathConfig

/** Test function to verify NAPI bindings work */
export declare function plus100(input: number): number

/** Property value types */
export declare const enum PropType {
  Null = 'Null',
  Bool = 'Bool',
  Int = 'Int',
  Float = 'Float',
  String = 'String'
}

/** Property value tag for binary encoding */
export declare const enum PropValueTag {
  Null = 0,
  Bool = 1,
  I64 = 2,
  F64 = 3,
  String = 4,
  VectorF32 = 5
}

/**
 * Create a traversal step
 *
 * @param direction - Traversal direction
 * @param edgeType - Optional edge type filter
 * @returns Traversal step object
 */
export declare function traversalStep(direction: JsTraversalDirection, edgeType?: number | undefined | null): JsTraversalStep

/** Get RayDB version */
export declare function version(): string
